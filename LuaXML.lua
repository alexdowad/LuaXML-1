--[[--
To use LuaXML, first import the module - for example like this:
	local xml = require("LuaXML")

LuaXML consists of a Lua file (`LuaXML.lua`) and a corresponding C module
(`LuaXML_lib`) - normally a shared library (`.dll`/`.so`), although a static
linking is possible as well. Both parts are imported by this call, provided
that they are found in Lua's package search path.

&nbsp;
@module LuaXML
]]--
local xml = require("LuaXML_lib")

--- symbolic name for tag index, this allows accessing the tag by `var[xml.TAG]`
xml.TAG = 0

--[[-- sets or returns tag of a LuaXML object.
This method is just "syntactic sugar" (using a typical Lua term) that allows
the writing of clearer code. LuaXML stores the tag value of an XML statement
at table index 0, hence it can be simply accessed or altered by `var[0]` or
`var[xml.TAG]` (the latter is just a symbolic name for the value 0). However,
writing `var:tag()` for access or `var:tag("newTag")` for altering may be
more self explanatory.

@function tag
@param var  the variable whose tag should be accessed, a LuaXML object
@tparam ?string tag  the new tag to be set
@return  the current tag as string
]]--
function xml.tag(var,tag)
	if type(var)~="table" then return end
	if type(tag)=="nil" then
		return var[xml.TAG]
	end
	var[xml.TAG] = tag
end

--[[-- creates a new LuaXML object.
This is achieved either by setting the metatable of an existing Lua table, or
by creating a new (empty) object and setting its tag.

Note that it's not mandatory to use this function in order to treat a Lua table
as LuaXML object. Setting the metatable just allows the usage of a more 
object-oriented syntax (e.g. `xmlvar:str()` instead of `xml.str(xmlvar)`).
XML objects created by `load` or `eval` automatically offer the
object-oriented syntax.

@function new
@param arg  (optional) _(1)_ a table to be converted to a LuaXML object,
or _(2)_ the tag of the new LuaXML object
@return  new LuaXML object
]]--
function xml.new(arg)
	if type(arg)=="table" then
		setmetatable(arg,{__index=xml, __tostring=xml.str})
		return arg
	end
	local var={}
	setmetatable(var,{__index=xml, __tostring=xml.str})
	if type(arg)=="string" then var[TAG]=arg end
	return var
end

--[[-- appends a new subordinate LuaXML object to an existing one.
optionally sets tag

@function append
@param var  the parent LuaXML object
@tparam ?string tag  the tag of the appended LuaXML object
@return  appended LuaXML object, or `nil` in case of errors
]]--
function xml.append(var,tag)
	if type(var)~="table" then return end
	local newVar = xml.new(tag)
	var[#var+1] = newVar
	return newVar
end

--[[-- converts any Lua var to an XML string.
@function str
@param var  the variable to be converted, normally a table
@tparam ?number indent  the current level of indentation for pretty output. Mainly for internal use.
@tparam ?string tag  the tag to be used for a table without tag. Mainly for internal use.
@treturn string  an XML string, or `nil` in case of errors
]]--
function xml.str(var,indent,tagValue)
	if type(var)=="nil" then return end
	local indent = indent or 0
	local indentStr=""
	for i = 1,indent do indentStr=indentStr.."	" end
	local tableStr=""

	if type(var)=="table" then
		local tag = var[0] or tagValue or type(var)
		local s = indentStr.."<"..tag
		for k,v in pairs(var) do -- attributes
			if type(k)=="string" then
				if type(v)=="table" and k~="_M" then -- otherwise recursiveness imminent
					tableStr = tableStr..xml.str(v,indent+1,k)
				else
					s = s.." "..k.."=\""..xml.encode(tostring(v)).."\""
				end
			end
		end
		if #var==0 and #tableStr==0 then
			s = s.." />\n"
		elseif #var==1 and type(var[1])~="table" and #tableStr==0 then -- single element
			s = s..">"..xml.encode(tostring(var[1])).."</"..tag..">\n"
		else
			s = s..">\n"
			for k,v in ipairs(var) do -- elements
				if type(v)=="string" then
					s = s..indentStr.."	"..xml.encode(v).." \n"
				else
					s = s..xml.str(v,indent+1)
				end
			end
			s=s..tableStr..indentStr.."</"..tag..">\n"
		end
		return s
	else
		local tag = type(var)
		return indentStr.."<"..tag..">"..xml.encode(tostring(var)).."</"..tag..">\n"
	end
end

--[[-- saves a Lua var as XML file.
Basically this simply exports the string representation `xml.str(var)`
(or `var:str()`), plus a standard header.

@function save
@param var  the variable to be saved, normally a table
@tparam string filename  the filename to be used. An existing file of the same name gets overwritten.
]]--
function xml.save(var,filename)
	if not var then return end
	if not filename or #filename==0 then return end
	local file = io.open(filename,"w")
	file:write("<?xml version=\"1.0\"?>\n<!-- file \"",filename, "\", generated by LuaXML -->\n\n")
	file:write(xml.str(var))
	io.close(file)
end

--[[-- recursively searches a Lua table for a subelement
matching the provided tag and attribute.

@function find
@param var  the table to be searched in
@tparam ?string tag  the XML tag to be found
@tparam ?string key  the attribute key (= exact name) to be found
@param value (optional)  the attribute value to be found
@return  the first (sub-)table which matches the search condition, or `nil`
]]--
function xml.find(var, tag, key, value)
	-- check input:
	if type(var)~="table" then return end
	if type(tag)=="string" and #tag==0 then tag=nil end
	if type(key)~="string" or #key==0 then key=nil end
	if type(value)=="string" and #value==0 then value=nil end
	-- compare this table:
	if tag~=nil then
		if var[0]==tag and ( value == nil or var[key]==value ) then
			setmetatable(var,{__index=xml, __tostring=xml.str})
			return var
		end
	else
		if value == nil or var[key]==value then
			setmetatable(var,{__index=xml, __tostring=xml.str})
			return var
		end
	end
	-- recursively parse subtags:
	for k, v in ipairs(var) do
		if type(v)=="table" then
			local ret = xml.find(v, tag, key, value)
			if ret ~= nil then return ret end
		end
	end
end

return xml
