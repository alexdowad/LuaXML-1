--[[--
To use LuaXML, first import the module - for example like this:
	local xml = require("LuaXML")

LuaXML consists of a Lua file (`LuaXML.lua`) and a corresponding C module
(`LuaXML_lib`) - normally a shared library (`.dll`/`.so`), although a static
linking is possible as well. Both parts are imported by this call, provided
that they are found in Lua's package search path.

&nbsp;
@module LuaXML
]]--
local xml = require("LuaXML_lib")

--[[-- appends a new subordinate LuaXML object to an existing one.
optionally sets tag

@function append
@param var  the parent LuaXML object
@tparam ?string tag  the tag of the appended LuaXML object
@return  appended LuaXML object, or `nil` in case of errors
]]--
function xml.append(var,tag)
	if type(var)~="table" then return end
	local newVar = xml.new(tag)
	var[#var+1] = newVar
	return newVar
end

--[[-- converts any Lua var to an XML string.
@function str
@param var  the variable to be converted, normally a table
@tparam ?number indent  the current level of indentation for pretty output. Mainly for internal use.
@tparam ?string tag  the tag to be used for a table without tag. Mainly for internal use.
@treturn string  an XML string, or `nil` in case of errors
]]--
function xml.str(var,indent,tagValue)
	if type(var)=="nil" then return end
	local indent = indent or 0
	local indentStr=""
	for i = 1,indent do indentStr=indentStr.."	" end
	local tableStr=""

	if type(var)=="table" then
		local tag = xml.tag(var) or tagValue or type(var)
		local s = indentStr.."<"..tag
		for k,v in pairs(var) do -- attributes
			if type(k)=="string" then
				if type(v)=="table" and k~="_M" then -- otherwise recursiveness imminent
					tableStr = tableStr..xml.str(v,indent+1,k)
				else
					s = s.." "..k.."=\""..xml.encode(tostring(v)).."\""
				end
			end
		end
		if #var==0 and #tableStr==0 then
			s = s.." />\n"
		elseif #var==1 and type(var[1])~="table" and #tableStr==0 then -- single element
			s = s..">"..xml.encode(tostring(var[1])).."</"..tag..">\n"
		else
			s = s..">\n"
			for k,v in ipairs(var) do -- elements
				if type(v)=="string" then
					s = s..indentStr.."	"..xml.encode(v).." \n"
				else
					s = s..xml.str(v,indent+1)
				end
			end
			s=s..tableStr..indentStr.."</"..tag..">\n"
		end
		return s
	else
		local tag = tagValue or type(var)
		return indentStr.."<"..tag..">"..xml.encode(tostring(var)).."</"..tag..">\n"
	end
end

--[[-- saves a Lua var as XML file.
Basically this simply exports the string representation `xml.str(var)`
(or `var:str()`), plus a standard header.

@function save
@param var  the variable to be saved, normally a table
@tparam string filename  the filename to be used. An existing file of the same name gets overwritten.
]]--
function xml.save(var,filename)
	if not var then return end
	if not filename or #filename==0 then return end
	local file = io.open(filename,"w")
	file:write("<?xml version=\"1.0\"?>\n<!-- file \"",filename, "\", generated by LuaXML -->\n\n")
	file:write(xml.str(var))
	io.close(file)
end

--[[-- recursively searches a Lua table for a subelement
matching the provided tag and attribute.

@function find
@param var  the table to be searched in
@tparam ?string tag  the XML tag to be found
@tparam ?string key  the attribute key (= exact name) to be found
@param value (optional)  the attribute value to be found
@return  the first (sub-)table which matches the search condition, or `nil`
]]--
function xml.find(var, tag, key, value)
	-- check input:
	if type(var)~="table" then return end
	if type(tag)=="string" and #tag==0 then tag=nil end
	if type(key)~="string" or #key==0 then key=nil end
	if type(value)=="string" and #value==0 then value=nil end
	-- compare this table:
	if tag == nil or xml.tag(var) == tag then
		if value == nil or var[key] == value then
			return xml.new(var)
		end
	end
	-- recursively parse subtags:
	for k, v in ipairs(var) do
		if type(v)=="table" then
			local ret = xml.find(v, tag, key, value)
			if ret ~= nil then return ret end
		end
	end
end

return xml
