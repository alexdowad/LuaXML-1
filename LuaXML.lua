--[[--
To use LuaXML, first import the module - for example like this:
	local xml = require("LuaXML")

LuaXML consists of a Lua file (`LuaXML.lua`) and a corresponding C module
(`LuaXML_lib`) - normally a shared library (`.dll`/`.so`), although a static
linking is possible as well. Both parts are imported by this call, provided
that they are found in Lua's package search path.

&nbsp;
@module LuaXML
]]--
local _M = require("LuaXML_lib")

--[[-- appends a new subordinate LuaXML object to an existing one.
optionally sets tag

@function append
@param var  the parent LuaXML object
@tparam ?string tag  the tag of the appended LuaXML object
@return  appended LuaXML object, or `nil` in case of errors
]]--
function _M.append(var, tag)
	if type(var) ~= "table" then return end
	local newVar = _M.new(tag)
	var[#var + 1] = newVar
	return newVar
end

--[[-- saves a Lua var as XML file.
Basically this simply exports the string representation `xml.str(var)`
(or `var:str()`), plus a standard header.

@function save
@param var  the variable to be saved, normally a table
@tparam string filename  the filename to be used. An existing file of the same name gets overwritten.
@tparam ?string filemode  the file mode to pass to `io.open`, defaults to "w"
]]--
function _M.save(var, filename, filemode)
	if not var then return end
	if not filename or #filename==0 then return end
	local file = io.open(filename, filemode or "w")
	file:write('<?xml version="1.0"?>\n<!-- file "', filename, '", generated by LuaXML -->\n\n')
	file:write(_M.str(var))
	io.close(file)
end

--[[-- recursively searches a Lua table for a subelement
matching the provided tag and attribute.

@function find
@param var  the table to be searched in
@tparam ?string tag  the XML tag to be found
@tparam ?string key  the attribute key (= exact name) to be found
@param value (optional)  the attribute value to be found
@return  the first (sub-)table which matches the search condition, or `nil`
]]--
function _M.find(var, tag, key, value)

	local function asstring(arg, strict)
		if type(arg) == "string" then
			if #arg == 0 then return nil; end
		else
			if strict then return nil; end
		end
		return arg
	end

	-- check input:
	if type(var) ~= "table" then return end
	tag = asstring(tag, false)
	key = asstring(key, true)
	value = asstring(value, false)

	-- compare this table:
	if tag == nil or _M.tag(var) == tag then
		if value == nil or var[key] == value then
			return _M.new(var)
		end
	end

	-- recursively parse subtags:
	for k, v in ipairs(var) do
		if type(v) == "table" then
			local ret = _M.find(v, tag, key, value)
			if ret ~= nil then return ret end -- return first non-empty match
		end
	end
end

return _M -- return module (table)
